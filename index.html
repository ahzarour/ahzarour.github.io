<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hotâ€“Cold Powerball Analyzer</title>
  <style>
    :root {
      --bg: #0f1220;
      --panel: #151935;
      --muted: #8a90b4;
      --text: #e7e9ff;
      --accent: #6ee7ff;
      --hot: #ff595a;
      --cold: #4f9bff;
      --natural: #34d399;
      --grid: #1d2249;
      --chip: #1b2042;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
        Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial,
        "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1000px 600px at 20% -10%,
          #1a1f46 0%,
          #0f1220 55%) no-repeat,
        var(--bg);
      color: var(--text);
    }

    a {
      color: var(--accent);
    }

    .wrap {
      max-width: 1200px;
      margin: 24px auto;
      padding: 0 16px;
    }

    /*header { display: grid; gap: 12px; grid-template-columns: 1fr auto; align-items: end; margin-bottom: 8px; }*/
    h1 {
      font-size: 28px;
      margin: 0;
      letter-spacing: 0.3px;
    }

    .sub {
      color: var(--muted);
      font-size: 13px;
      margin-top: 6px;
    }

    .panel {
      background: linear-gradient(180deg,
          rgba(255, 255, 255, 0.03),
          rgba(255, 255, 255, 0)),
        var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 16px;
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .g-2 {
      grid-template-columns: 1fr;
    }

    @media (min-width: 980px) {
      .g-2 {
        grid-template-columns: 1fr 1fr;
      }
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 12px;
    }

    label {
      font-size: 13px;
      color: var(--muted);
    }

    input[type="range"] {
      width: 100%;
    }

    .val {
      font-variant-numeric: tabular-nums;
      background: var(--chip);
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
    }

    .btns {
      display: grid;
      margin: 20px 0;
    }

    button,
    .filelabel {
      background: #232a61;
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: 120ms ease;
    }

    button:hover,
    .filelabel:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
    }

    input[type="file"] {
      display: none;
    }

    .legend {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 6px;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 6px;
    }

    /* Make each cell its own sizing container */
    .cell {
      container-type: inline-size;
      /* enables cqi units */
      aspect-ratio: 1 / 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.2em;
      /* space between strong/small */
      place-items: center;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: var(--chip);
      position: relative;
      overflow: hidden;
      padding: 0.25rem;
      /* tiny breathing room */
    }

    /* Top line (number) scales with the cell width */
    .cell strong {
      display: block;
      line-height: 1;
      font-weight: 700;
      /* min size, scale with container (cqi), cap at a max */
      font-size: clamp(0.8rem, 55cqi, 2rem);
    }

    /* Bottom line (draws) also scales, but smaller */
    .cell small {
      display: block;
      line-height: 1.05;
      font-size: clamp(0.6rem, 28cqi, 1.2rem);
      opacity: 0.9;
    }

    /*.cell small { position: absolute; bottom: 4px; right: 6px; color: var(--muted); font-variant-numeric: tabular-nums; font-size: 10px; }*/
    .cell.hot {
      outline: 2px solid var(--hot);
      box-shadow: inset 0 0 0 999px rgba(255, 89, 90, 0.08);
    }

    .cell.cold {
      outline: 2px solid var(--cold);
      box-shadow: inset 0 0 0 999px rgba(79, 155, 255, 0.08);
    }

    .cell.natural {
      outline: 2px solid var(--natural);
      box-shadow: inset 0 0 0 999px rgba(52, 211, 153, 0.08);
    }

    .badge {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      background: #20265a;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .meta {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 12px;
    }

    /* Responsive date inputs inside the date-controls column */
    .date-controls .date-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    /* Date inputs scale with viewport but never get too small or too large */
    .date-controls input[type="date"] {
      width: clamp(50px, 16vw, 320px);
      max-width: 50%;
      box-sizing: border-box;
    }

    .tables {
      display: grid;
      grid-template-columns: 1fr 1fr;
      /*gap: 16px;*/
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    th,
    td {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      text-align: left;
    }

    thead th {
      color: var(--muted);
      font-weight: 600;
    }

    canvas {
      width: 100% !important;
      height: 320px !important;
      background: #101537;
      border-radius: 16px;
      padding: 10px;
    }

    .footer {
      color: var(--muted);
      font-size: 12px;
      text-align: center;
      margin: 16px 0 40px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Hotâ€“Cold Powerball Analyzer</h1>
        <div class="sub">
          Upload your Powerball CSV â†’ autoâ€‘detect columns â†’ compute
          frequencies â†’ classify <strong>Hot</strong>, <strong>Cold</strong>,
          and <strong>Natural</strong> numbers for <em>White (1â€“69)</em> and
          <em>Red (1â€“26)</em>.
        </div>
      </div>
      <div class="btns">
        <label class="filelabel" for="csvFile">ðŸ“„ Load CSV</label>
        <input id="csvFile" type="file" accept=".csv,text/csv" />
      </div>
    </header>

    <section class="panel" style="margin-bottom: 16px; padding: 16px">
      <div id="dateRange" class="meta date-range" style="
            display: flex;
            gap: 16px;
            align-items: flex-start;
            flex-wrap: nowrap;
            overflow-x: auto;
          ">
        <div class="date-labels" style="display: flex; flex-direction: column; gap: 14px">
          <div style="font-size: 13px; color: var(--muted)">Quick range:</div>
          <div style="font-size: 13px; color: var(--muted)">From</div>
          <div style="font-size: 13px; color: var(--muted)">Date Range</div>
          <div style="font-size: 13px; color: var(--muted)">Draws</div>
        </div>

        <div class="date-controls" style="
              display: flex;
              flex-direction: column;
              gap: 12px;
              flex: 1;
              min-width: 0;
            ">
          <div>
            <select id="datePreset" style="width: auto">
              <option value="since-2015-10-07">From 10/07/2015</option>
              <option value="1m">Last month</option>
              <option value="3m">Last 3 months</option>
              <option value="6m">Last 6 months</option>
              <option value="1y">Last year</option>
              <option value="2y">Last 2 years</option>
              <option value="3y">Last 3 years</option>
              <option value="all">All time</option>
              <option value="custom">Custom dates</option>
            </select>
          </div>

          <div style="display: flex; gap: 8px; align-items: center">
            <input id="dateFromInput" type="date" style="width: auto" />
            <div style="white-space: nowrap; color: var(--muted)">to</div>
            <input id="dateToInput" type="date" style="width: auto" />
          </div>

          <div>
            <div style="color: var(--muted)">
              <strong id="dateFrom">â€”â€”</strong> to
              <strong id="dateTo">â€”â€”</strong>
            </div>
          </div>

          <div>
            <div id="drawsInfo" class="meta date-range">
              <strong id="drawsCount">â€”â€”â€”â€”â€”</strong>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel" style="margin-bottom: 16px">
      <div class="controls">
        <div>
          <div class="row">
            <label for="hotPct">Hot threshold (top % by frequency)</label><span class="val" id="hotPctVal">20%</span>
          </div>
          <input id="hotPct" type="range" min="5" max="40" step="1" value="20" />
        </div>
        <div>
          <div class="row">
            <label for="coldPct">Cold threshold (bottom % by frequency)</label><span class="val"
              id="coldPctVal">20%</span>
          </div>
          <input id="coldPct" type="range" min="5" max="40" step="1" value="20" />
        </div>
      </div>
      <div class="meta" style="margin-top: 12px">
        <span>Mode: <span class="badge">Percentile</span></span>
        <span>Classification:
          <span class="badge" id="classSummary">â€”</span></span>
        <span id="datasetMeta">No data loaded yet.</span>
      </div>
    </section>

    <section class="grid g-2">
      <div class="panel">
        <div style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              margin-bottom: 8px;
            ">
          <h2 style="margin: 0; font-size: 18px; padding: 8px">
            White Numbers (1â€“69)
          </h2>
          <div class="legend">
            <span><i class="dot" style="background: var(--hot)"></i>Hot</span>
            <span><i class="dot" style="background: var(--natural)"></i>Natural</span>
            <span><i class="dot" style="background: var(--cold)"></i>Cold</span>
          </div>
        </div>
        <div id="whiteBoard" class="board" aria-live="polite"></div>
        <div style="margin-top: 14px">
          <canvas id="whiteChart"></canvas>
        </div>
      </div>

      <div class="panel">
        <div style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              margin-bottom: 8px;
            ">
          <h2 style="margin: 0; font-size: 18px; padding: 8px">
            Red Numbers (Powerball 1â€“26)
          </h2>
          <div class="legend">
            <span><i class="dot" style="background: var(--hot)"></i>Hot</span>
            <span><i class="dot" style="background: var(--natural)"></i>Natural</span>
            <span><i class="dot" style="background: var(--cold)"></i>Cold</span>
          </div>
        </div>
        <div id="redBoard" class="board" aria-live="polite" style="grid-template-columns: repeat(10, 1fr)"></div>
        <div style="margin-top: 14px">
          <canvas id="redChart"></canvas>
        </div>
      </div>
    </section>

    <section class="panel" style="margin-top: 16px">
      <h2 style="margin: 0 0 8px 0; font-size: 18px">Frequency Tables</h2>
      <div class="tables">
        <div>
          <h3 style="margin: 0 0 8px 0; font-size: 15px; color: var(--muted)">
            White
          </h3>
          <div style="
                max-height: 340px;
                overflow: auto;
                border: 1px solid rgba(255, 255, 255, 0.06);
                border-radius: 12px;
              ">
            <table id="whiteTable">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Count</th>
                  <th>Class</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
        <div>
          <h3 style="margin: 0 0 8px 0; font-size: 15px; color: var(--muted)">
            Red
          </h3>
          <div style="
                max-height: 340px;
                overflow: auto;
                border: 1px solid rgba(255, 255, 255, 0.06);
                border-radius: 12px;
              ">
            <table id="redTable">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Count</th>
                  <th>Class</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </section>

    <section class="panel" style="margin-top: 16px; text-wrap-mode: nowrap">
      <h2 style="margin: 0 0 8px 0; font-size: 18px">Combination patterns</h2>
      <div style="
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 12px;
            padding: 8px;
          ">
        <table id="comboTable" style="width: 100%; border-collapse: collapse">
          <thead>
            <tr>
              <th style="text-align: left; padding: 8px">Combination</th>
              <th style="width: 90px; text-align: right; padding: 8px">
                Count
              </th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <p class="footer">
      Tip: the app autoâ€‘detects common schemas like
      <em>winning_numbers</em> with spaceâ€‘separated values (last is red), or
      columns like <em>white1â€¦white5</em> plus <em>powerball/pb</em>.
      Everything stays on your device.
    </p>
  </div>

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <script>
    // --- Utilities ---
    const WHITE_MAX = 69;
    const RED_MAX = 26;

    function normalizeHeader(h) {
      return h.trim().toLowerCase().replaceAll(/\s+|_/g, "");
    }

    function quickCSVParse(text) {
      // Lightweight CSV parser: handles commas, quoted fields, newlines in quotes.
      const rows = [];
      let i = 0,
        field = "",
        row = [],
        inQuotes = false;
      while (i < text.length) {
        const c = text[i];
        if (inQuotes) {
          if (c === '"') {
            if (text[i + 1] === '"') {
              field += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            field += c;
          }
        } else {
          if (c === '"') {
            inQuotes = true;
          } else if (c === ",") {
            row.push(field);
            field = "";
          } else if (c === "\n") {
            row.push(field);
            rows.push(row);
            row = [];
            field = "";
          } else if (c === "\r") {
            /* ignore */
          } else {
            field += c;
          }
        }
        i++;
      }
      if (field.length || row.length) {
        row.push(field);
        rows.push(row);
      }
      return rows;
    }

    function toObjects(rows) {
      if (!rows.length) return [];
      const header = rows[0].map(normalizeHeader);
      return rows
        .slice(1)
        .filter((r) => r.length && r.some((x) => String(x).trim().length))
        .map((r) => {
          const o = {};
          for (let i = 0; i < header.length; i++)
            o[header[i]] = (r[i] ?? "").toString().trim();
          return o;
        });
    }

    function parseDraws(objs) {
      // Attempt schema detection for whites (array of up to 5) + red (single)
      const draws = [];
      const keys = objs.length ? Object.keys(objs[0]) : [];
      const has = (k) => keys.includes(k);
      const findKey = (...cands) => cands.find((k) => keys.includes(k));

      // Heuristics for explicit columns
      const whiteCandidates = [];
      for (let i = 1; i <= 7; i++) {
        [
          "white" + i,
          "w" + i,
          "n" + i,
          "num" + i,
          "ball" + i,
          "wb" + i,
        ].forEach((k) => {
          if (has(k)) whiteCandidates.push(k);
        });
      }
      const redKey = findKey("powerball", "pb", "red", "r", "power", "pball");

      // Heuristic for combined string column like "winning_numbers"
      const combinedKey = findKey(
        "winningnumbers",
        "winningnumber",
        "numbers",
        "winning",
        "results"
      );

      for (const row of objs) {
        let whites = [],
          red = null;
        if (whiteCandidates.length) {
          for (const k of whiteCandidates) {
            const v = row[k];
            if (/^-?\d+$/.test(v)) {
              const n = parseInt(v, 10);
              if (n > 0) whites.push(n);
            }
          }
          // keep first 5 ascending if too many
          whites = whites.filter((n) => n >= 1 && n <= WHITE_MAX).slice(0, 5);
          if (redKey && /^-?\d+$/.test(row[redKey])) {
            red = parseInt(row[redKey], 10);
          }
        } else if (combinedKey && row[combinedKey]) {
          // Split on spaces, commas, hyphens. Last token often the red ball
          const toks = row[combinedKey]
            .split(/[\s,;-]+/)
            .map((t) => t.trim())
            .filter(Boolean);
          const nums = toks
            .filter((t) => /^\d+$/.test(t))
            .map((t) => parseInt(t, 10));
          if (nums.length >= 6) {
            whites = nums.slice(0, 5).filter((n) => n >= 1 && n <= WHITE_MAX);
            red = nums[5];
          } else if (nums.length === 6) {
            /* same */
          } else if (nums.length >= 1) {
            // Some feeds have separate PB column and combined whites of 5 tokens
            if (nums.length >= 5) whites = nums.slice(0, 5);
          }
        }
        if (whites.length >= 5) {
          if (!(red >= 1 && red <= RED_MAX)) {
            // Try other red hints
            const altRedKey = Object.keys(row).find((k) =>
              /powerball|\bpb\b|red/.test(k)
            );
            if (altRedKey && /^\d+$/.test(row[altRedKey]))
              red = parseInt(row[altRedKey], 10);
          }
          draws.push({
            whites,
            red: red >= 1 && red <= RED_MAX ? red : null,
          });
        }
      }
      return draws;
    }

    function tally(draws) {
      const white = Array(WHITE_MAX + 1).fill(0);
      const red = Array(RED_MAX + 1).fill(0);
      for (const d of draws) {
        for (const n of d.whites) {
          if (n >= 1 && n <= WHITE_MAX) white[n]++;
        }
        if (d.red != null && d.red >= 1 && d.red <= RED_MAX) red[d.red]++; // allow null reds
      }
      return { white, red };
    }

    function classifyByPercentile(counts, topPct = 20, bottomPct = 20) {
      const arr = counts.slice(1); // ignore index 0
      const sorted = [...arr].sort((a, b) => a - b);
      const n = sorted.length;
      const q = (p) =>
        sorted[Math.min(n - 1, Math.max(0, Math.round((p / 100) * (n - 1))))];
      const coldMax = q(bottomPct);
      const hotMin = q(100 - topPct);
      const cls = counts.map((c, i) => {
        if (i === 0) return "skip";
        if (c <= coldMax) return "cold";
        if (c >= hotMin) return "hot";
        return "natural";
      });
      return { cls, coldMax, hotMin };
    }

    function renderBoard(el, max, counts, cls) {
      el.innerHTML = "";
      for (let i = 1; i <= max; i++) {
        const div = document.createElement("div");
        div.className = `cell ${cls[i]}`;
        div.title = `#${i} â€¢ ${counts[i]} draws â€¢ ${cls[i]}`;
        div.innerHTML = `<strong>${i}</strong><small>${counts[i]}</small>`;
        el.appendChild(div);
      }
    }

    function renderTable(tbody, max, counts, cls) {
      tbody.innerHTML = "";
      for (let i = 1; i <= max; i++) {
        const tr = document.createElement("tr");
        const c = cls[i];
        const color =
          c === "hot"
            ? "var(--hot)"
            : c === "cold"
              ? "var(--cold)"
              : "var(--natural)";
        tr.innerHTML = `<td>#${i}</td><td>${counts[i]}</td><td><span class="badge" style="background:transparent;border:1px solid ${color}; color:${color}">${c}</span></td>`;
        tbody.appendChild(tr);
      }
    }

    let whiteChart, redChart;
    function drawChart(ctx, label, max, counts, cls) {
      const labels = Array.from({ length: max }, (_, i) =>
        (i + 1).toString()
      );
      const data = labels.map((_, i) => counts[i + 1]);
      const bg = labels.map((_, i) =>
        cls[i + 1] === "hot"
          ? "rgba(255,89,90,0.9)"
          : cls[i + 1] === "cold"
            ? "rgba(79,155,255,0.9)"
            : "rgba(52,211,153,0.9)"
      );
      return new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            { label: label + " frequency", data, backgroundColor: bg },
          ],
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: (ctx) => ` #${ctx.label}: ${ctx.formattedValue}`,
              },
            },
          },
          scales: {
            x: { ticks: { color: "#c9d0ff" } },
            y: {
              ticks: { color: "#c9d0ff" },
              beginAtZero: true,
              grace: "10%",
            },
          },
        },
      });
    }

    function rebuildCharts(counts, cls) {
      if (whiteChart) whiteChart.destroy();
      if (redChart) redChart.destroy();
      whiteChart = drawChart(
        document.getElementById("whiteChart"),
        "White",
        WHITE_MAX,
        counts.white,
        cls.white.cls
      );
      redChart = drawChart(
        document.getElementById("redChart"),
        "Red",
        RED_MAX,
        counts.red,
        cls.red.cls
      );
    }

    function exportCSV(counts, classes) {
      const rows = [["group", "number", "count", "class"]];
      for (let i = 1; i <= WHITE_MAX; i++)
        rows.push(["white", i, counts.white[i], classes.white.cls[i]]);
      for (let i = 1; i <= RED_MAX; i++)
        rows.push(["red", i, counts.red[i], classes.red.cls[i]]);
      const csv = rows.map((r) => r.join(",")).join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "powerball_hot_cold_results.csv";
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 5000);
    }

    // --- App State ---
    const state = {
      draws: [],
      counts: null,
      classes: null,
      hotPct: 20,
      coldPct: 20,
    };

    function updateClassification() {
      if (!state.counts) return;
      const whiteCls = classifyByPercentile(
        state.counts.white,
        state.hotPct,
        state.coldPct
      );
      const redCls = classifyByPercentile(
        state.counts.red,
        state.hotPct,
        state.coldPct
      );
      state.classes = { white: whiteCls, red: redCls };
      document.getElementById(
        "classSummary"
      ).textContent = `Hot â‰¥ ${whiteCls.hotMin} â€¢ Cold â‰¤ ${whiteCls.coldMax}`;
      renderBoard(
        document.getElementById("whiteBoard"),
        WHITE_MAX,
        state.counts.white,
        whiteCls.cls
      );
      renderBoard(
        document.getElementById("redBoard"),
        RED_MAX,
        state.counts.red,
        redCls.cls
      );
      renderTable(
        document.querySelector("#whiteTable tbody"),
        WHITE_MAX,
        state.counts.white,
        whiteCls.cls
      );
      renderTable(
        document.querySelector("#redTable tbody"),
        RED_MAX,
        state.counts.red,
        redCls.cls
      );
      rebuildCharts(state.counts, state.classes);
      renderCombinationTable();
      const exportBtn = document.getElementById("exportBtn");
      if (exportBtn) exportBtn.disabled = false;
    }

    function computeCombinationCounts() {
      if (!state.draws || !state.classes) return new Map();
      const combos = new Map();
      for (const d of state.draws) {
        const wcls = d.whites.map(
          (n) => state.classes.white.cls[n] || "natural"
        );
        const counts = { hot: 0, cold: 0, natural: 0 };
        for (const c of wcls) counts[c] = (counts[c] || 0) + 1;
        const redClass = d.red
          ? state.classes.red.cls[d.red] || "natural"
          : "unknown";
        const key = `${counts.hot} Hot, ${counts.natural} Natural, ${counts.cold} Cold | Red: ${redClass}`;
        combos.set(key, (combos.get(key) || 0) + 1);
      }
      return combos;
    }

    function renderCombinationTable() {
      const tbody = document.querySelector("#comboTable tbody");
      if (!tbody) return;
      tbody.innerHTML = "";
      const combos = computeCombinationCounts();
      const rows = Array.from(combos.entries()).sort((a, b) => b[1] - a[1]);
      for (const [k, v] of rows) {
        const tr = document.createElement("tr");
        const td1 = document.createElement("td");
        td1.textContent = k;
        td1.style.padding = "8px";
        const td2 = document.createElement("td");
        td2.textContent = v.toLocaleString();
        td2.style.textAlign = "right";
        td2.style.padding = "8px";
        tr.appendChild(td1);
        tr.appendChild(td2);
        tbody.appendChild(tr);
      }
      if (!rows.length) {
        const tr = document.createElement("tr");
        tr.innerHTML =
          '<td colspan="2" style="padding:8px;color:var(--muted)">No combinations yet.</td>';
        tbody.appendChild(tr);
      }
    }

    // We'll keep the original parsed objects so we can re-filter by date without reparsing the CSV
    let _lastParsedObjects = null;

    function applyDateFilterAndRecompute() {
      if (!_lastParsedObjects) return;
      // Determine date range from inputs; if preset 'all' then no filtering
      const preset = document.getElementById("datePreset").value;
      const fromInput = document.getElementById("dateFromInput").value;
      const toInput = document.getElementById("dateToInput").value;
      let from = null,
        to = null;
      const today = new Date();
      const startOfDay = (d) => {
        const x = new Date(d);
        x.setHours(0, 0, 0, 0);
        return x;
      };
      const endOfDay = (d) => {
        const x = new Date(d);
        x.setHours(23, 59, 59, 999);
        return x;
      };

      if (preset && preset.startsWith("since-")) {
        // presets of the form `since-YYYY-MM-DD` mean from that date up to today
        const dateStr = preset.slice("since-".length);
        const parsed = new Date(dateStr);
        if (!isNaN(parsed)) {
          from = startOfDay(parsed);
          to = endOfDay(today);
        }
      } else if (preset !== "custom" && preset !== "all") {
        // compute relative ranges (months/years)
        const m = preset;
        if (m.endsWith("m")) {
          const months = parseInt(m.slice(0, -1), 10);
          to = endOfDay(today);
          from = startOfDay(
            new Date(today.getFullYear(), today.getMonth() - months + 1, 1)
          );
        } else if (m.endsWith("y")) {
          const years = parseInt(m.slice(0, -1), 10);
          to = endOfDay(today);
          from = startOfDay(new Date(today.getFullYear() - years + 1, 0, 1));
        }
      } else if (preset === "custom") {
        if (fromInput) from = startOfDay(new Date(fromInput));
        if (toInput) to = endOfDay(new Date(toInput));
      }

      // Build draws from parsed objects and filter by date if we have from/to
      const allDraws = [];
      // We need to detect which key contains date if any
      const keys = Object.keys(_lastParsedObjects[0] || {});
      const dateKey =
        keys.find((k) => /date|drawdate|draw_date|draw/.test(k)) || keys[0];

      for (const row of _lastParsedObjects) {
        const parsedDate = (row[dateKey] || "").trim();
        let dObj = null;
        if (parsedDate) {
          const dt = Date.parse(parsedDate);
          if (!isNaN(dt)) dObj = new Date(dt);
          else {
            const m = parsedDate.match(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
            if (m) {
              let mm = parseInt(m[1], 10),
                dd = parseInt(m[2], 10),
                yy = parseInt(m[3], 10);
              if (yy < 100) yy += 2000;
              dObj = new Date(yy, mm - 1, dd);
            }
          }
        }
        allDraws.push({ row, date: dObj });
      }

      const filteredObjs =
        from || to
          ? allDraws
            .filter((x) => {
              if (!x.date) return false;
              if (from && x.date < from) return false;
              if (to && x.date > to) return false;
              return true;
            })
            .map((x) => x.row)
          : _lastParsedObjects.slice();

      // Now parse draws from filtered objects
      const draws = parseDraws(filteredObjs);
      state.draws = draws;
      state.counts = tally(draws);

      const totalDraws = draws.length;
      const redsWithValue = draws.filter((d) => d.red != null).length;
      document.getElementById(
        "datasetMeta"
      ).textContent = `Analyzing ${totalDraws.toLocaleString()} draws â€¢ Reds present in ${redsWithValue.toLocaleString()} rows`;
      const drawsEl = document.getElementById("drawsCount");
      if (drawsEl)
        drawsEl.textContent = totalDraws ? totalDraws.toLocaleString() : "â€”";

      // Update detected range display to the applied filter or the full CSV range when 'all'
      if (from && to) {
        document.getElementById("dateFrom").textContent = from
          .toISOString()
          .slice(0, 10);
        document.getElementById("dateTo").textContent = to
          .toISOString()
          .slice(0, 10);
      } else if (document.getElementById("datePreset").value === "all") {
        const dr = extractDateRange(_lastParsedObjects);
        if (dr) {
          document.getElementById("dateFrom").textContent = dr.from;
          document.getElementById("dateTo").textContent = dr.to;
        }
      }

      updateClassification();
    }

    function loadFromCSVText(text) {
      const rows = quickCSVParse(text);
      const objs = toObjects(rows);
      _lastParsedObjects = objs; // store for filtering

      // Initialize UI date inputs to full range
      const dr = extractDateRange(objs);
      if (dr) {
        document.getElementById("dateFrom").textContent = dr.from;
        document.getElementById("dateTo").textContent = dr.to;
        // set inputs default to the full range
        const fi = document.getElementById("dateFromInput");
        const ti = document.getElementById("dateToInput");
        if (fi) fi.value = dr.from;
        if (ti) ti.value = dr.to;
      } else {
        document.getElementById("dateFrom").textContent = "â€”";
        document.getElementById("dateTo").textContent = "â€”";
      }

      // By default apply 'all' (no filter)
      document.getElementById("datePreset").value = "all";
      applyDateFilterAndRecompute();
    }

    // --- Date range extraction ---
    function extractDateRange(objs) {
      if (!objs || !objs.length) return null;
      const keys = Object.keys(objs[0]);
      // Prefer obvious date-like keys
      const dateKeyCandidates = keys.filter((k) =>
        /date|drawdate|draw_date|draw/.test(k)
      );
      const scanKeys = dateKeyCandidates.length ? dateKeyCandidates : keys;

      const dates = [];
      const mdSlash = /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/; // mm/dd/yyyy or m/d/yy
      const iso = /^\d{4}-\d{2}-\d{2}$/;

      for (const row of objs) {
        for (const k of scanKeys) {
          const v = (row[k] || "").trim();
          if (!v) continue;
          let d = null;
          if (iso.test(v)) d = new Date(v);
          else {
            const m = v.match(mdSlash);
            if (m) {
              let mm = parseInt(m[1], 10),
                dd = parseInt(m[2], 10),
                yy = parseInt(m[3], 10);
              if (yy < 100) yy += 2000;
              d = new Date(yy, mm - 1, dd);
            } else {
              const pd = Date.parse(v);
              if (!isNaN(pd)) d = new Date(pd);
            }
          }
          if (d && !isNaN(d)) dates.push(d);
        }
      }
      if (!dates.length) return null;
      const min = new Date(Math.min(...dates));
      const max = new Date(Math.max(...dates));
      const fmt = (d) => d.toISOString().slice(0, 10);
      return { from: fmt(min), to: fmt(max) };
    }

    // --- Events ---
    document.getElementById("csvFile").addEventListener("change", (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => loadFromCSVText(String(reader.result));
      reader.readAsText(f);
    });

    document.getElementById("hotPct").addEventListener("input", (e) => {
      state.hotPct = parseInt(e.target.value, 10);
      document.getElementById("hotPctVal").textContent = state.hotPct + "%";
      updateClassification();
    });

    document.getElementById("coldPct").addEventListener("input", (e) => {
      state.coldPct = parseInt(e.target.value, 10);
      document.getElementById("coldPctVal").textContent = state.coldPct + "%";
      updateClassification();
    });

    // Removed Export Results button and its event listener

    // Initialize labels
    document.getElementById("hotPctVal").textContent = state.hotPct + "%";
    document.getElementById("coldPctVal").textContent = state.coldPct + "%";

    // Date range control events
    document.getElementById("datePreset").addEventListener("change", (e) => {
      const v = e.target.value;
      const fi = document.getElementById("dateFromInput");
      const ti = document.getElementById("dateToInput");
      if (v === "custom") {
        fi.disabled = false;
        ti.disabled = false;
      } else {
        fi.disabled = true;
        ti.disabled = true;
        // For convenience, when user picks a preset compute and populate inputs
        const today = new Date();
        if (v && v.startsWith("since-")) {
          const dateStr = v.slice("since-".length);
          const parsed = new Date(dateStr);
          if (!isNaN(parsed)) {
            const from = new Date(parsed);
            fi.value = from.toISOString().slice(0, 10);
            ti.value = today.toISOString().slice(0, 10);
            applyDateFilterAndRecompute();
            return;
          }
        }
        if (v === "all") {
          const dr = extractDateRange(_lastParsedObjects || []);
          if (dr) {
            fi.value = dr.from;
            ti.value = dr.to;
          }
          applyDateFilterAndRecompute();
        } else if (v.endsWith("m")) {
          const months = parseInt(v.slice(0, -1), 10);
          const to = new Date();
          const from = new Date(
            to.getFullYear(),
            to.getMonth() - months + 1,
            1
          );
          fi.value = from.toISOString().slice(0, 10);
          ti.value = to.toISOString().slice(0, 10);
          applyDateFilterAndRecompute();
        } else if (v.endsWith("y")) {
          const years = parseInt(v.slice(0, -1), 10);
          const to = new Date();
          const from = new Date(to.getFullYear() - years + 1, 0, 1);
          fi.value = from.toISOString().slice(0, 10);
          ti.value = to.toISOString().slice(0, 10);
          applyDateFilterAndRecompute();
        }
      }
    });

    // Auto-apply when custom date inputs change
    const _fi = document.getElementById("dateFromInput");
    const _ti = document.getElementById("dateToInput");
    if (_fi)
      _fi.addEventListener("change", () => {
        document.getElementById("datePreset").value = "custom";
        applyDateFilterAndRecompute();
      });
    if (_ti)
      _ti.addEventListener("change", () => {
        document.getElementById("datePreset").value = "custom";
        applyDateFilterAndRecompute();
      });
  </script>
</body>

</html>