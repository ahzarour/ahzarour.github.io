<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ø¥Ù„Ø¹Ø¨ Ù…Ø§ ØªÙ„Ø¹Ø¨</title>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Readex+Pro:wght@160..700&display=swap");

    :root {
      --bg: #0f1220;
      --panel: #151935;
      --muted: #8a90b4;
      --text: #e7e9ff;
      --accent: #6ee7ff;
      --hot: #ff595a;
      --cold: #4f9bff;
      --natural: #34d399;
      --grid: #1d2249;
      --chip: #1b2042;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
        Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial,
        "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1000px 600px at 20% -10%,
          #1a1f46 0%,
          #0f1220 55%) no-repeat,
        var(--bg);
      color: var(--text);
    }

    a {
      color: var(--accent);
    }

    .wrap {
      max-width: 1200px;
      margin: 24px auto;
      padding: 0 16px;
    }

    /*header { display: grid; gap: 12px; grid-template-columns: 1fr auto; align-items: end; margin-bottom: 8px; }*/
    h1 {
      font-size: 28px;
      margin: 0;
      letter-spacing: 0.3px;
      font-family: "Readex Pro", sans-serif;
    }

    .sub {
      color: var(--muted);
      font-size: 13px;
      margin-top: 6px;
    }

    .panel {
      background: linear-gradient(180deg,
          rgba(255, 255, 255, 0.03),
          rgba(255, 255, 255, 0)),
        var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 16px;
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .g-2 {
      grid-template-columns: 1fr;
    }

    @media (min-width: 980px) {
      .g-2 {
        grid-template-columns: 1fr 1fr;
      }
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 12px;
    }

    label {
      font-size: 13px;
      color: var(--muted);
    }

    input[type="range"] {
      width: 100%;
    }

    .val {
      font-variant-numeric: tabular-nums;
      background: var(--chip);
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
    }

    .btns {
      display: grid;
      margin: 20px 0;
    }

    button,
    .filelabel {
      max-width: fit-content;
      background: #232a61;
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: 120ms ease;
    }

    button:hover,
    .filelabel:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
    }

    input[type="file"] {
      display: none;
    }

    .legend {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 6px;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 6px;
    }

    /* Make each cell its own sizing container */
    .cell {
      container-type: inline-size;
      /* enables cqi units */
      aspect-ratio: 1 / 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0.2em;
      /* space between strong/small */
      place-items: center;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: var(--chip);
      position: relative;
      overflow: hidden;
      padding: 0.25rem;
      /* tiny breathing room */
    }

    /* Top line (number) scales with the cell width */
    .cell strong {
      display: block;
      line-height: 1;
      font-weight: 700;
      /* min size, scale with container (cqi), cap at a max */
      font-size: clamp(0.8rem, 55cqi, 2rem);
    }

    /* Bottom line (draws) also scales, but smaller */
    .cell small {
      display: block;
      line-height: 1.05;
      font-size: clamp(0.6rem, 28cqi, 1.2rem);
      opacity: 0.9;
    }

    /*.cell small { position: absolute; bottom: 4px; right: 6px; color: var(--muted); font-variant-numeric: tabular-nums; font-size: 10px; }*/
    .cell.hot {
      outline: 2px solid var(--hot);
      box-shadow: inset 0 0 0 999px rgba(255, 89, 90, 0.08);
    }

    .cell.cold {
      outline: 2px solid var(--cold);
      box-shadow: inset 0 0 0 999px rgba(79, 155, 255, 0.08);
    }

    .cell.natural {
      outline: 2px solid var(--natural);
      box-shadow: inset 0 0 0 999px rgba(52, 211, 153, 0.08);
    }

    .badge {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      background: #20265a;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .meta {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 12px;
    }

    /* Responsive date inputs inside the date-controls column */
    .date-controls .date-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    /* Date inputs scale with viewport but never get too small or too large */
    .date-controls input[type="date"] {
      width: clamp(50px, 16vw, 320px);
      max-width: 50%;
      box-sizing: border-box;
    }

    .tables {
      display: grid;
      grid-template-columns: 1fr 1fr;
      /*gap: 16px;*/
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    th,
    td {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      text-align: left;
    }

    thead th {
      color: var(--muted);
      font-weight: 600;
    }

    /* Hidden scrollbar container for combo table */
    .combo-scroll {
      max-height: 224px;
      /* ~5 rows visible including header */
      overflow: auto;
      -ms-overflow-style: none;
      /* IE/Edge */
      scrollbar-width: none;
      /* Firefox */
    }

    .combo-scroll::-webkit-scrollbar {
      /* Chrome/Safari */
      width: 0;
      height: 0;
    }

    /* Hidden scrollbar container for Number Cruncher */
    .crunch-scroll {
      max-height: 224px;
      /* about 5 rows visible */
      overflow: auto;
      -ms-overflow-style: none;
      /* IE/Edge */
      scrollbar-width: none;
      /* Firefox */
    }

    .crunch-scroll::-webkit-scrollbar {
      /* Chrome/Safari */
      width: 0;
      height: 0;
    }

    /* Hidden scrollbar container for Frequency Tables */
    .freq-scroll {
      max-height: 340px; /* matches current containers */
      overflow: auto;
      -ms-overflow-style: none; /* IE/Edge */
      scrollbar-width: none;     /* Firefox */
    }
    .freq-scroll::-webkit-scrollbar { /* Chrome/Safari */
      width: 0;
      height: 0;
    }

    canvas {
      width: 100% !important;
      height: 320px !important;
      background: #101537;
      border-radius: 16px;
      padding: 10px;
    }

    .footer {
      color: var(--muted);
      font-size: 12px;
      text-align: center;
      margin: 0px;
      padding: 30px 40px 40px 40px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div style="
            display: flex;
            flex-direction: column;
            gap: 6px;
            text-align: center;
          ">
        <h1 style="direction: rtl; padding: 14px 0">
          ØªØ­Ù„ÙŠÙ„ Ø¥Ù„Ø¹Ø¨ Ù…Ø§ ØªÙ„Ø¹Ø¨ !!!
        </h1>
        <div class="sub" style="
              max-width: 600px;
              margin: 0 auto;
              direction: ltr;
              text-align: left;
            ">
          Upload your Powerball CSV â†’ autoâ€‘detect columns â†’ compute
          frequencies â†’ classify <strong>Hot</strong>, <strong>Cold</strong>,
          and <strong>Natural</strong> numbers for <em>White (1â€“69)</em> and
          <em>Red (1â€“26)</em>.
        </div>
      </div>
      <div class="btns" style="align-items: center; justify-content: center">
        <label class="filelabel" for="csvFile">ðŸ“„ Load Historic Data txt</label>
        <input id="csvFile" type="file" accept=".csv,.CSV,.txt,text/csv,text/plain" />
      </div>
    </header>

    <section class="panel" style="margin-bottom: 16px; padding: 16px">
      <div id="dateRange" class="meta date-range" style="
            display: flex;
            gap: 16px;
            align-items: flex-start;
            flex-wrap: nowrap;
            overflow-x: auto;
          ">
        <div class="date-labels" style="display: flex; flex-direction: column; gap: 14px">
          <div style="font-size: 13px; color: var(--muted)">Quick range:</div>
          <div style="font-size: 13px; color: var(--muted)">From</div>
          <div style="font-size: 13px; color: var(--muted)">Date Range</div>
          <div style="font-size: 13px; color: var(--muted)">Draws</div>
        </div>

        <div class="date-controls" style="
              display: flex;
              flex-direction: column;
              gap: 12px;
              flex: 1;
              min-width: 0;
            ">
          <div>
            <select id="datePreset" style="width: auto">
              <option value="since-2015-10-07">From 10/07/2015</option>
              <option value="1m">Last month</option>
              <option value="3m">Last 3 months</option>
              <option value="6m">Last 6 months</option>
              <option value="1y">Last year</option>
              <option value="2y">Last 2 years</option>
              <option value="3y">Last 3 years</option>
              <option value="all" selected>All time</option>
              <option value="custom">Custom dates</option>
            </select>
          </div>

          <div style="display: flex; gap: 8px; align-items: center">
            <input id="dateFromInput" type="date" style="width: auto" />
            <div style="white-space: nowrap; color: var(--muted)">to</div>
            <input id="dateToInput" type="date" style="width: auto" />
          </div>

          <div>
            <div style="color: var(--muted)">
              <strong id="dateFrom">â€”â€”</strong> to
              <strong id="dateTo">â€”â€”</strong>
            </div>
          </div>

          <div>
            <div id="drawsInfo" class="meta date-range">
              <strong id="drawsCount">â€”â€”â€”â€”â€”</strong>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="panel" style="margin-bottom: 16px">
      <div class="controls">
        <div>
          <div class="row">
            <label for="hotPct">Hot threshold (top % by frequency)</label><span class="val" id="hotPctVal">20%</span>
          </div>
          <input id="hotPct" type="range" min="5" max="40" step="1" value="20" />
        </div>
        <div>
          <div class="row">
            <label for="coldPct">Cold threshold (bottom % by frequency)</label><span class="val"
              id="coldPctVal">20%</span>
          </div>
          <input id="coldPct" type="range" min="5" max="40" step="1" value="20" />
        </div>
      </div>
      <div class="meta" style="margin-top: 12px">
        <span>Mode: <span class="badge">Percentile</span></span>
        <span>Classification:
          <span class="badge" id="classSummary">â€”</span></span>
        <span id="datasetMeta">No data loaded yet.</span>
      </div>
    </section>

    <section class="grid g-2">
      <div class="panel">
        <div style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              margin-bottom: 8px;
            ">
          <h2 style="margin: 0; font-size: 18px; padding: 8px">
            White Numbers (1â€“69)
          </h2>
          <div class="legend">
            <span><i class="dot" style="background: var(--hot)"></i>Hot</span>
            <span><i class="dot" style="background: var(--natural)"></i>Natural</span>
            <span><i class="dot" style="background: var(--cold)"></i>Cold</span>
          </div>
        </div>
        <div id="whiteBoard" class="board" aria-live="polite"></div>
        <!-- charts removed -->
      </div>

      <div class="panel">
        <div style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              margin-bottom: 8px;
            ">
          <h2 style="margin: 0; font-size: 18px; padding: 8px">
            Red Numbers (Powerball 1â€“26)
          </h2>
          <div class="legend">
            <span><i class="dot" style="background: var(--hot)"></i>Hot</span>
            <span><i class="dot" style="background: var(--natural)"></i>Natural</span>
            <span><i class="dot" style="background: var(--cold)"></i>Cold</span>
          </div>
        </div>
        <div id="redBoard" class="board" aria-live="polite" style="grid-template-columns: repeat(10, 1fr)"></div>
        <!-- charts removed -->
      </div>
    </section>

    <section class="panel" style="margin-top: 16px">
      <h2 style="margin: 0 0 8px 0; font-size: 18px">Frequency Tables</h2>
      <div class="tables">
        <div>
          <h3 style="margin: 0 0 8px 0; font-size: 15px; color: var(--muted)">
            White
          </h3>
          <div class="freq-scroll" style="
                max-height: 340px;
                overflow: auto;
                border: 1px solid rgba(255, 255, 255, 0.06);
                border-radius: 12px;
              ">
            <table id="whiteTable">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Count</th>
                  <th>Class</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
        <div>
          <h3 style="margin: 0 0 8px 0; font-size: 15px; color: var(--muted)">
            Red
          </h3>
          <div class="freq-scroll" style="
                max-height: 340px;
                overflow: auto;
                border: 1px solid rgba(255, 255, 255, 0.06);
                border-radius: 12px;
              ">
            <table id="redTable">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Count</th>
                  <th>Class</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </section>

    <section class="panel" style="margin-top: 16px; text-wrap-mode: nowrap">
      <h2 style="margin: 0 0 8px 0; font-size: 18px">Combination patterns</h2>
      <div class="combo-scroll" style="
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 12px;
            padding: 8px;
          ">
        <table id="comboTable" style="width: 100%; border-collapse: collapse">
          <thead>
            <tr>
              <th style="text-align: left; padding: 8px">Combination</th>
              <th style="width: 90px; text-align: right; padding: 8px">
                Count
              </th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>


    <!--Number Cruncher-->
    <section class="panel" style="margin-top: 16px">
      <h2 style="margin: 0 0 8px 0; font-size: 18px">Number Cruncher</h2>
      <div class="meta" style="justify-content: space-between; align-items:center; margin-bottom: 8px;">
        <span style="color: var(--muted)">Sorted by <strong>Qty</strong> â€¢ <em>Show All enables sorting</em></span>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="crunchToggleBtn" type="button">Show All</button>
          <button id="crunchSortBtn" type="button" disabled>Sort 1â†’69</button>
          <button id="crunchSortPBBtn" type="button" disabled>Sort as PB</button>
        </div>
      </div>
      <div id="crunchScrollWrap" class="crunch-scroll"
        style="border: 1px solid rgba(255,255,255,0.06); border-radius:12px;">
        <table id="crunchTable">
          <thead>
            <tr>
              <th>#</th>
              <th>Qty Drawn</th>
              <th>% of total balls drawn</th>
              <th>Last Drawn</th>
              <th>Total as Powerball</th>
              <th>% of total draws held</th>
              <th>Last drawn as Powerball</th>
            </tr>
          </thead>
          <tbody>
            <!-- Rows will be populated by JavaScript -->
          </tbody>
        </table>
      </div>
      <div style="color:var(--muted); font-size:12px; margin-top:8px; line-height:1.5;">
        <div>White-ball % = (Qty Drawn Ã· (Draws Ã— 5)) Ã— 100</div>
        <div>Powerball % = (Total as Powerball Ã· draws with a Powerball value) Ã— 100</div>
        <div>Dates reflect the current filter above.</div>
      </div>
    </section>






    <!-- ---------------- footer ----------- -->
    <p class="footer">
      Plan Don't Play is copyrited <strong>&copy; 2025 Ahmed Zarour</strong>
      <br /><strong>All rights reserved.</strong>
    </p>
  </div>

  <!-- Charting removed -->

  <script>
    // --- Utilities ---
    const WHITE_MAX = 69;
    const RED_MAX = 26;

    // --- Date helpers ---
    function parseDateDMY(value) {
      if (!value) return null;
      const v = String(value).trim();
      // ISO (YYYY-MM-DD)
      if (/^\d{4}-\d{2}-\d{2}$/.test(v)) {
        const d = new Date(v);
        return isNaN(d) ? null : d;
      }
      // DMY with / or - separators (dd/mm/yyyy or d/m/yy)
      const m = v.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
      if (m) {
        let dd = parseInt(m[1], 10);
        let mm = parseInt(m[2], 10);
        let yy = parseInt(m[3], 10);
        if (yy < 100) yy += 2000;
        const d = new Date(yy, mm - 1, dd);
        return isNaN(d) ? null : d;
      }
      // Fallback (rare)
      const p = Date.parse(v);
      return isNaN(p) ? null : new Date(p);
    }
    function fmtISO(d) {
      return d.toISOString().slice(0, 10);
    }
    function fmtDMY(d) {
      const dd = String(d.getDate()).padStart(2, "0");
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const yy = d.getFullYear();
      return `${dd}/${mm}/${yy}`;
    }

    function normalizeHeader(h) {
      return h.trim().toLowerCase().replaceAll(/\s+|_/g, "");
    }

    function quickCSVParse(text) {
      // Lightweight CSV parser: handles commas, quoted fields, newlines in quotes.
      const rows = [];
      let i = 0,
        field = "",
        row = [],
        inQuotes = false;
      while (i < text.length) {
        const c = text[i];
        if (inQuotes) {
          if (c === '"') {
            if (text[i + 1] === '"') {
              field += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            field += c;
          }
        } else {
          if (c === '"') {
            inQuotes = true;
          } else if (c === ",") {
            row.push(field);
            field = "";
          } else if (c === "\n") {
            row.push(field);
            rows.push(row);
            row = [];
            field = "";
          } else if (c === "\r") {
            /* ignore */
          } else {
            field += c;
          }
        }
        i++;
      }
      if (field.length || row.length) {
        row.push(field);
        rows.push(row);
      }
      return rows;
    }

    function toObjects(rows) {
      if (!rows.length) return [];
      const header = rows[0].map(normalizeHeader);
      return rows
        .slice(1)
        .filter((r) => r.length && r.some((x) => String(x).trim().length))
        .map((r) => {
          const o = {};
          for (let i = 0; i < header.length; i++)
            o[header[i]] = (r[i] ?? "").toString().trim();
          return o;
        });
    }


    // === Number Cruncher helpers ===
    function extractWhitesRed(row) {
      const keys = Object.keys(row);
      const has = (k) => keys.includes(k);
      const findKey = (...cands) => cands.find((k) => keys.includes(k));

      // Try explicit columns (white1..white5, w1..w5, n1..n5, etc.)
      const whiteCandidates = [];
      for (let i = 1; i <= 7; i++) {
        ["white" + i, "w" + i, "n" + i, "num" + i, "ball" + i, "wb" + i].forEach((k) => {
          if (has(k)) whiteCandidates.push(k);
        });
      }
      const redKey = findKey("powerball", "pb", "red", "r", "power", "pball");

      // Or a combined column like "winningnumbers"
      const combinedKey = findKey(
        "winningnumbers", "winningnumber", "numbers", "winning", "results"
      );

      let whites = [], red = null;
      if (whiteCandidates.length) {
        for (const k of whiteCandidates) {
          const v = row[k];
          if (/^-?\d+$/.test(v)) {
            const n = parseInt(v, 10);
            if (n > 0) whites.push(n);
          }
        }
        whites = whites.filter((n) => n >= 1 && n <= WHITE_MAX).slice(0, 5);
        if (redKey && /^-?\d+$/.test(row[redKey])) red = parseInt(row[redKey], 10);
      } else if (combinedKey && row[combinedKey]) {
        const toks = row[combinedKey].split(/[\s,;-]+/).map((t) => t.trim()).filter(Boolean);
        const nums = toks.filter((t) => /^\d+$/.test(t)).map((t) => parseInt(t, 10));
        if (nums.length >= 6) {
          whites = nums.slice(0, 5).filter((n) => n >= 1 && n <= WHITE_MAX);
          red = nums[5];
        } else if (nums.length >= 5) {
          whites = nums.slice(0, 5);
        }
      }
      return { whites, red: red >= 1 && red <= RED_MAX ? red : null };
    }




    function parseDraws(objs) {
      // Attempt schema detection for whites (array of up to 5) + red (single)
      const draws = [];
      const keys = objs.length ? Object.keys(objs[0]) : [];
      const has = (k) => keys.includes(k);
      const findKey = (...cands) => cands.find((k) => keys.includes(k));

      // Heuristics for explicit columns
      const whiteCandidates = [];
      for (let i = 1; i <= 7; i++) {
        [
          "white" + i,
          "w" + i,
          "n" + i,
          "num" + i,
          "ball" + i,
          "wb" + i,
        ].forEach((k) => {
          if (has(k)) whiteCandidates.push(k);
        });
      }
      const redKey = findKey("powerball", "pb", "red", "r", "power", "pball");

      // Heuristic for combined string column like "winning_numbers"
      const combinedKey = findKey(
        "winningnumbers",
        "winningnumber",
        "numbers",
        "winning",
        "results"
      );

      for (const row of objs) {
        let whites = [],
          red = null;
        if (whiteCandidates.length) {
          for (const k of whiteCandidates) {
            const v = row[k];
            if (/^-?\d+$/.test(v)) {
              const n = parseInt(v, 10);
              if (n > 0) whites.push(n);
            }
          }
          // keep first 5 ascending if too many
          whites = whites.filter((n) => n >= 1 && n <= WHITE_MAX).slice(0, 5);
          if (redKey && /^-?\d+$/.test(row[redKey])) {
            red = parseInt(row[redKey], 10);
          }
        } else if (combinedKey && row[combinedKey]) {
          // Split on spaces, commas, hyphens. Last token often the red ball
          const toks = row[combinedKey]
            .split(/[\s,;-]+/)
            .map((t) => t.trim())
            .filter(Boolean);
          const nums = toks
            .filter((t) => /^\d+$/.test(t))
            .map((t) => parseInt(t, 10));
          if (nums.length >= 6) {
            whites = nums.slice(0, 5).filter((n) => n >= 1 && n <= WHITE_MAX);
            red = nums[5];
          } else if (nums.length === 6) {
            /* same */
          } else if (nums.length >= 1) {
            // Some feeds have separate PB column and combined whites of 5 tokens
            if (nums.length >= 5) whites = nums.slice(0, 5);
          }
        }
        if (whites.length >= 5) {
          if (!(red >= 1 && red <= RED_MAX)) {
            // Try other red hints
            const altRedKey = Object.keys(row).find((k) =>
              /powerball|\bpb\b|red/.test(k)
            );
            if (altRedKey && /^\d+$/.test(row[altRedKey]))
              red = parseInt(row[altRedKey], 10);
          }
          draws.push({
            whites,
            red: red >= 1 && red <= RED_MAX ? red : null,
          });
        }
      }
      return draws;
    }

    function tally(draws) {
      const white = Array(WHITE_MAX + 1).fill(0);
      const red = Array(RED_MAX + 1).fill(0);
      for (const d of draws) {
        for (const n of d.whites) {
          if (n >= 1 && n <= WHITE_MAX) white[n]++;
        }
        if (d.red != null && d.red >= 1 && d.red <= RED_MAX) red[d.red]++; // allow null reds
      }
      return { white, red };
    }

    function classifyByPercentile(counts, topPct = 20, bottomPct = 20) {
      const arr = counts.slice(1); // ignore index 0
      const sorted = [...arr].sort((a, b) => a - b);
      const n = sorted.length;
      const q = (p) =>
        sorted[Math.min(n - 1, Math.max(0, Math.round((p / 100) * (n - 1))))];
      const coldMax = q(bottomPct);
      const hotMin = q(100 - topPct);
      const cls = counts.map((c, i) => {
        if (i === 0) return "skip";
        if (c <= coldMax) return "cold";
        if (c >= hotMin) return "hot";
        return "natural";
      });
      return { cls, coldMax, hotMin };
    }

    function renderBoard(el, max, counts, cls) {
      el.innerHTML = "";
      for (let i = 1; i <= max; i++) {
        const div = document.createElement("div");
        div.className = `cell ${cls[i]}`;
        div.title = `#${i} â€¢ ${counts[i]} draws â€¢ ${cls[i]}`;
        div.innerHTML = `<strong>${i}</strong><small>${counts[i]}</small>`;
        el.appendChild(div);
      }
    }

    function renderTable(tbody, max, counts, cls) {
      // Build an array of items so we can sort/group them by class
      tbody.innerHTML = "";
      const items = [];
      for (let i = 1; i <= max; i++) {
        items.push({ num: i, count: counts[i], cls: cls[i] });
      }

      // Order classes to group them together in the table. Legend order: Hot, Natural, Cold
      const classOrder = { hot: 0, natural: 1, cold: 2 };

      // Sort by class group, then by count descending, then by number ascending
      items.sort((a, b) => {
        const ca = classOrder[a.cls] ?? 3;
        const cb = classOrder[b.cls] ?? 3;
        if (ca !== cb) return ca - cb;
        if (b.count !== a.count) return b.count - a.count;
        return a.num - b.num;
      });

      for (const it of items) {
        const tr = document.createElement("tr");
        const color =
          it.cls === "hot"
            ? "var(--hot)"
            : it.cls === "cold"
              ? "var(--cold)"
              : "var(--natural)";
        tr.innerHTML = `<td>#${it.num}</td><td>${it.count}</td><td><span class="badge" style="background:transparent;border:1px solid ${color}; color:${color}">${it.cls}</span></td>`;
        tbody.appendChild(tr);
      }
    }

    // Charting removed: canvas elements and Chart.js usage deleted

    function exportCSV(counts, classes) {
      const rows = [["group", "number", "count", "class"]];
      for (let i = 1; i <= WHITE_MAX; i++)
        rows.push(["white", i, counts.white[i], classes.white.cls[i]]);
      for (let i = 1; i <= RED_MAX; i++)
        rows.push(["red", i, counts.red[i], classes.red.cls[i]]);
      const csv = rows.map((r) => r.join(",")).join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "powerball_hot_cold_results.csv";
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 5000);
    }

    // --- App State ---
    const state = {
      draws: [],
      counts: null,
      classes: null,
      hotPct: 20,
      coldPct: 20,
      crunchShowAll: false,
      crunchSortByNumberAsc: false,
      crunchSortByPB: false,
    };

    function updateClassification() {
      if (!state.counts) return;
      const whiteCls = classifyByPercentile(
        state.counts.white,
        state.hotPct,
        state.coldPct
      );
      const redCls = classifyByPercentile(
        state.counts.red,
        state.hotPct,
        state.coldPct
      );
      state.classes = { white: whiteCls, red: redCls };
      document.getElementById(
        "classSummary"
      ).textContent = `Hot â‰¥ ${whiteCls.hotMin} â€¢ Cold â‰¤ ${whiteCls.coldMax}`;
      renderBoard(
        document.getElementById("whiteBoard"),
        WHITE_MAX,
        state.counts.white,
        whiteCls.cls
      );
      renderBoard(
        document.getElementById("redBoard"),
        RED_MAX,
        state.counts.red,
        redCls.cls
      );
      renderTable(
        document.querySelector("#whiteTable tbody"),
        WHITE_MAX,
        state.counts.white,
        whiteCls.cls
      );
      renderTable(
        document.querySelector("#redTable tbody"),
        RED_MAX,
        state.counts.red,
        redCls.cls
      );
      // rebuildCharts(state.counts, state.classes);
      renderCombinationTable();
      const exportBtn = document.getElementById("exportBtn");
      if (exportBtn) exportBtn.disabled = false;
    }

    function computeCombinationCounts() {
      if (!state.draws || !state.classes) return new Map();
      const combos = new Map();
      for (const d of state.draws) {
        const wcls = d.whites.map(
          (n) => state.classes.white.cls[n] || "natural"
        );
        const counts = { hot: 0, cold: 0, natural: 0 };
        for (const c of wcls) counts[c] = (counts[c] || 0) + 1;
        const redClass = d.red
          ? state.classes.red.cls[d.red] || "natural"
          : "unknown";
        const key = `${counts.hot} Hot, ${counts.natural} Natural, ${counts.cold} Cold | Red: ${redClass}`;
        combos.set(key, (combos.get(key) || 0) + 1);
      }
      return combos;
    }

    function renderCombinationTable() {
      const tbody = document.querySelector("#comboTable tbody");
      if (!tbody) return;
      tbody.innerHTML = "";
      const combos = computeCombinationCounts();
      const rows = Array.from(combos.entries()).sort((a, b) => b[1] - a[1]);
      for (const [k, v] of rows) {
        const tr = document.createElement("tr");
        const td1 = document.createElement("td");
        td1.textContent = k;
        td1.style.padding = "8px";
        const td2 = document.createElement("td");
        td2.textContent = v.toLocaleString();
        td2.style.textAlign = "right";
        td2.style.padding = "8px";
        tr.appendChild(td1);
        tr.appendChild(td2);
        tbody.appendChild(tr);
      }
      if (!rows.length) {
        const tr = document.createElement("tr");
        tr.innerHTML =
          '<td colspan="2" style="padding:8px;color:var(--muted)">No combinations yet.</td>';
        tbody.appendChild(tr);
      }
    }


    function renderCrunchTable() {
      const tbody = document.querySelector('#crunchTable tbody');
      const wrap = document.getElementById('crunchScrollWrap');
      const toggleBtn = document.getElementById('crunchToggleBtn');
      if (!tbody || !state.counts || !state.draws) return;
      tbody.innerHTML = '';

      const totalDraws = state.draws.length;
      const totalWhiteBalls = totalDraws * 5;
      const totalRedsPresent = state.draws.reduce((acc, d) => acc + (d.red ? 1 : 0), 0);

      // Track last-drawn dates per number
      const lastWhite = Array(WHITE_MAX + 1).fill(null);
      const lastRed = Array(RED_MAX + 1).fill(null);
      for (const d of state.draws) {
        const dt = d.date;
        if (dt) {
          for (const n of d.whites) {
            if (!lastWhite[n] || dt > lastWhite[n]) lastWhite[n] = dt;
          }
          if (d.red) {
            const r = d.red;
            if (!lastRed[r] || dt > lastRed[r]) lastRed[r] = dt;
          }
        }
      }

      // Collect rows for all numbers
      const rows = [];
      for (let n = 1; n <= WHITE_MAX; n++) {
        const qtyWhite = state.counts.white[n] || 0;
        const pctWhite = totalWhiteBalls ? (qtyWhite / totalWhiteBalls) * 100 : 0;
        const lastW = lastWhite[n] ? fmtDMY(lastWhite[n]) : 'â€”';

        const qtyRed = n <= RED_MAX ? (state.counts.red[n] || 0) : 0;
        const pctRed = (n <= RED_MAX && totalRedsPresent) ? (qtyRed / totalRedsPresent) * 100 : 0;
        const lastR = (n <= RED_MAX && lastRed[n]) ? fmtDMY(lastRed[n]) : 'â€”';

        rows.push({ n, qtyWhite, pctWhite, lastW, qtyRed, pctRed, lastR });
      }

      // Decide sorting (Show All enables sort options)
      const sortByPB = state.crunchShowAll && state.crunchSortByPB;
      const sortByNumber = state.crunchShowAll && state.crunchSortByNumberAsc;
      if (sortByPB) {
        rows.sort((a, b) => b.qtyRed - a.qtyRed || a.n - b.n);
      } else if (sortByNumber) {
        rows.sort((a, b) => a.n - b.n);
      } else {
        // default: sort by white quantity desc
        rows.sort((a, b) => b.qtyWhite - a.qtyWhite || a.n - b.n);
      }

      // Decide how many to show
      const visibleRows = state.crunchShowAll ? rows : rows.slice(0, 5);

      // Keep same style class; only adjust max-height
      if (wrap) {
        if (!wrap.classList.contains('crunch-scroll')) wrap.classList.add('crunch-scroll');
        wrap.style.maxHeight = state.crunchShowAll ? 'none' : '224px';
      }
      if (toggleBtn) toggleBtn.textContent = state.crunchShowAll ? 'Show Top 5' : 'Show All';

      // Update sort button state
      const sortBtn = document.getElementById('crunchSortBtn');
      const sortPBBtn = document.getElementById('crunchSortPBBtn');
      if (sortBtn) {
        sortBtn.disabled = !state.crunchShowAll; // only active when showing all
        // If PB sort is active, keep this showing the default option label
        sortBtn.textContent = state.crunchSortByNumberAsc ? 'Sort by Qty' : 'Sort 1â†’69';
      }
      if (sortPBBtn) {
        sortPBBtn.disabled = !state.crunchShowAll; // only active when showing all
        sortPBBtn.textContent = state.crunchSortByPB ? 'Sort by Qty' : 'Sort as PB';
      }

      // Render
      for (const r of visibleRows) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
      <td>${r.n}</td>
      <td>${r.qtyWhite.toLocaleString()}</td>
      <td>${r.pctWhite.toFixed(2)}%</td>
      <td>${r.lastW}</td>
      <td>${r.qtyRed ? r.qtyRed.toLocaleString() : 0}</td>
      <td>${r.qtyRed ? r.pctRed.toFixed(2) + '%' : '0%'}</td>
      <td>${r.lastR}</td>
    `;
        tbody.appendChild(tr);
      }
    }



    // We'll keep the original parsed objects so we can re-filter by date without reparsing the CSV
    let _lastParsedObjects = null;

    function applyDateFilterAndRecompute() {
      if (!_lastParsedObjects) return;
      // Determine date range from inputs; if preset 'all' then no filtering
      const preset = document.getElementById("datePreset").value;
      const fromInput = document.getElementById("dateFromInput").value;
      const toInput = document.getElementById("dateToInput").value;
      let from = null,
        to = null;
      const today = new Date();
      const startOfDay = (d) => {
        const x = new Date(d);
        x.setHours(0, 0, 0, 0);
        return x;
      };
      const endOfDay = (d) => {
        const x = new Date(d);
        x.setHours(23, 59, 59, 999);
        return x;
      };

      if (preset && preset.startsWith("since-")) {
        // presets of the form `since-YYYY-MM-DD` mean from that date up to today
        const dateStr = preset.slice("since-".length);
        const parsed = new Date(dateStr);
        if (!isNaN(parsed)) {
          from = startOfDay(parsed);
          to = endOfDay(today);
        }
      } else if (preset !== "custom" && preset !== "all") {
        // compute relative ranges (months/years)
        const m = preset;
        if (m.endsWith("m")) {
          const months = parseInt(m.slice(0, -1), 10);
          to = endOfDay(today);
          from = startOfDay(
            new Date(today.getFullYear(), today.getMonth() - months + 1, 1)
          );
        } else if (m.endsWith("y")) {
          const years = parseInt(m.slice(0, -1), 10);
          to = endOfDay(today);
          from = startOfDay(new Date(today.getFullYear() - years + 1, 0, 1));
        }
      } else if (preset === "custom") {
        if (fromInput) from = startOfDay(new Date(fromInput));
        if (toInput) to = endOfDay(new Date(toInput));
      }


      // Build list with date attached
      const keys = Object.keys(_lastParsedObjects[0] || {});
      const dateKey = keys.find((k) => /date|drawdate|draw_date|draw/.test(k)) || keys[0];

      const dated = [];
      for (const row of _lastParsedObjects) {
        const parsedDate = (row[dateKey] || "").trim();
        const dObj = parseDateDMY(parsedDate);
        dated.push({ row, date: dObj });
      }

      const filtered = from || to
        ? dated.filter((x) => {
          if (!x.date) return false;
          if (from && x.date < from) return false;
          if (to && x.date > to) return false;
          return true;
        })
        : dated;

      const draws = [];
      for (const { row, date } of filtered) {
        const { whites, red } = extractWhitesRed(row);
        if (whites && whites.length >= 5) {
          draws.push({ whites, red, date });
        }
      }
      state.draws = draws;
      // counts only need numeric parts
      state.counts = tally(draws.map(d => ({ whites: d.whites, red: d.red })));


      const totalDraws = draws.length;
      const redsWithValue = draws.filter((d) => d.red != null).length;
      document.getElementById(
        "datasetMeta"
      ).textContent = `Analyzing ${totalDraws.toLocaleString()} draws â€¢ Reds present in ${redsWithValue.toLocaleString()} rows`;
      const drawsEl = document.getElementById("drawsCount");
      if (drawsEl)
        drawsEl.textContent = totalDraws ? totalDraws.toLocaleString() : "â€”";

      // Update detected range display to the applied filter or the full CSV range when 'all'
      if (from && to) {
        document.getElementById("dateFrom").textContent = fmtDMY(from);
        document.getElementById("dateTo").textContent = fmtDMY(to);
      } else if (document.getElementById("datePreset").value === "all") {
        const dr = extractDateRange(_lastParsedObjects);
        if (dr) {
          document.getElementById("dateFrom").textContent = dr.from;
          document.getElementById("dateTo").textContent = dr.to;
        }
      }

      updateClassification();
      renderCrunchTable();

    }

    function loadFromCSVText(text) {
      const rows = quickCSVParse(text);
      const objs = toObjects(rows);
      _lastParsedObjects = objs; // store for filtering

      // Extract date range from the loaded CSV
      const dr = extractDateRange(objs);
      const fi = document.getElementById("dateFromInput");
      const ti = document.getElementById("dateToInput");
      if (dr) {
        // Set the display for oldest and newest dates (DMY)
        document.getElementById("dateFrom").textContent = dr.from;
        document.getElementById("dateTo").textContent = dr.to;
        // Set date inputs to full range (ISO)
        if (fi) fi.value = dr.fromISO;
        if (ti) ti.value = dr.toISO;
      } else {
        document.getElementById("dateFrom").textContent = "â€”";
        document.getElementById("dateTo").textContent = "â€”";
        if (fi) fi.value = "";
        if (ti) ti.value = "";
      }

      // Set preset to 'all' and disable date inputs
      const preset = document.getElementById("datePreset");
      if (preset) preset.value = "all";
      if (fi) fi.disabled = true;
      if (ti) ti.disabled = true;

      // Run analysis for the full range
      applyDateFilterAndRecompute();
    }

    // --- Date range extraction ---
    function extractDateRange(objs) {
      if (!objs || !objs.length) return null;
      const keys = Object.keys(objs[0]);
      // Prefer obvious date-like keys
      const dateKeyCandidates = keys.filter((k) =>
        /date|drawdate|draw_date|draw/.test(k)
      );
      const scanKeys = dateKeyCandidates.length ? dateKeyCandidates : keys;

      const dates = [];
      for (const row of objs) {
        for (const k of scanKeys) {
          const v = (row[k] || "").trim();
          if (!v) continue;
          const d = parseDateDMY(v);
          if (d) dates.push(d);
        }
      }
      if (!dates.length) return null;
      const min = new Date(Math.min(...dates));
      const max = new Date(Math.max(...dates));
      return {
        from: fmtDMY(min),
        to: fmtDMY(max),
        fromISO: fmtISO(min),
        toISO: fmtISO(max),
      };
    }

    // --- Events ---
    document.getElementById("csvFile").addEventListener("change", (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => loadFromCSVText(String(reader.result));
      reader.readAsText(f);
    });

    document.getElementById("hotPct").addEventListener("input", (e) => {
      state.hotPct = parseInt(e.target.value, 10);
      document.getElementById("hotPctVal").textContent = state.hotPct + "%";
      updateClassification();
    });

    document.getElementById("coldPct").addEventListener("input", (e) => {
      state.coldPct = parseInt(e.target.value, 10);
      document.getElementById("coldPctVal").textContent = state.coldPct + "%";
      updateClassification();
    });

    // Removed Export Results button and its event listener

    // Initialize labels
    document.getElementById("hotPctVal").textContent = state.hotPct + "%";
    document.getElementById("coldPctVal").textContent = state.coldPct + "%";

    // Date range control events
    document.getElementById("datePreset").addEventListener("change", (e) => {
      const v = e.target.value;
      const fi = document.getElementById("dateFromInput");
      const ti = document.getElementById("dateToInput");
      if (v === "custom") {
        fi.disabled = false;
        ti.disabled = false;
      } else {
        fi.disabled = true;
        ti.disabled = true;
        // For convenience, when user picks a preset compute and populate inputs
        const today = new Date();
        if (v && v.startsWith("since-")) {
          const dateStr = v.slice("since-".length);
          const parsed = new Date(dateStr);
          if (!isNaN(parsed)) {
            const from = new Date(parsed);
            fi.value = from.toISOString().slice(0, 10);
            ti.value = today.toISOString().slice(0, 10);
            applyDateFilterAndRecompute();
            return;
          }
        }
        if (v === "all") {
          const dr = extractDateRange(_lastParsedObjects || []);
          if (dr) {
            fi.value = dr.fromISO;
            ti.value = dr.toISO;
          }
          applyDateFilterAndRecompute();
        } else if (v.endsWith("m")) {
          const months = parseInt(v.slice(0, -1), 10);
          const to = new Date();
          const from = new Date(
            to.getFullYear(),
            to.getMonth() - months + 1,
            1
          );
          fi.value = from.toISOString().slice(0, 10);
          ti.value = to.toISOString().slice(0, 10);
          applyDateFilterAndRecompute();
        } else if (v.endsWith("y")) {
          const years = parseInt(v.slice(0, -1), 10);
          const to = new Date();
          const from = new Date(to.getFullYear() - years + 1, 0, 1);
          fi.value = from.toISOString().slice(0, 10);
          ti.value = to.toISOString().slice(0, 10);
          applyDateFilterAndRecompute();
        }
      }
    });

    // Auto-apply when custom date inputs change
    const _fi = document.getElementById("dateFromInput");
    const _ti = document.getElementById("dateToInput");
    if (_fi)
      _fi.addEventListener("change", () => {
        document.getElementById("datePreset").value = "custom";
        applyDateFilterAndRecompute();
      });
    if (_ti)
      _ti.addEventListener("change", () => {
        document.getElementById("datePreset").value = "custom";
        applyDateFilterAndRecompute();
      });
    // Toggle Show All / Top 5 for Number Cruncher
    (function attachCrunchToggle() {
      const crunchBtn = document.getElementById('crunchToggleBtn');
      if (!crunchBtn) return;
      crunchBtn.addEventListener('click', () => {
        state.crunchShowAll = !state.crunchShowAll;
        renderCrunchTable();
      });
    })();

    // Toggle sort mode for Number Cruncher (only effective when Show All)
    (function attachCrunchSort(){
      const sortBtn = document.getElementById('crunchSortBtn');
      if (!sortBtn) return;
      sortBtn.addEventListener('click', () => {
        state.crunchSortByNumberAsc = !state.crunchSortByNumberAsc;
        if (state.crunchSortByNumberAsc) state.crunchSortByPB = false;
        renderCrunchTable();
      });
    })();

    // Toggle PB sort mode (only effective when Show All). Selecting PB sort clears number sort.
    (function attachCrunchSortPB(){
      const pbBtn = document.getElementById('crunchSortPBBtn');
      if (!pbBtn) return;
      pbBtn.addEventListener('click', () => {
        state.crunchSortByPB = !state.crunchSortByPB;
        if (state.crunchSortByPB) state.crunchSortByNumberAsc = false;
        renderCrunchTable();
      });
    })();
  </script>

</body>

</html>